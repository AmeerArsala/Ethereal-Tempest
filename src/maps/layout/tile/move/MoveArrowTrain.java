/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package maps.layout.tile.move;

import com.jme3.asset.AssetManager;
import com.jme3.math.ColorRGBA;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import maps.layout.MapCoords;
import maps.layout.tile.TileFoundation;

/**
 *
 * @author night
 */
public class MoveArrowTrain { //head must move with the Cursor
    private final HashMap<MapCoords, MoveArrowTile> loadedArrowTiles = new HashMap<>();
    private final LinkedList<MoveArrowTile> train = new LinkedList<>(); //last index is destination
    private final AssetManager assetManager;
    private int capacity; //determines train size; if the size becomes higher than this OR a conflict occurs, train becomes autogenerated
    
    public MoveArrowTrain(AssetManager assetManager, int capacity) {
        this.assetManager = assetManager;
        this.capacity = capacity;
    }
    
    public MoveArrowTrain(AssetManager assetManager) {
        this.assetManager = assetManager;
        capacity = 0;
    }
    
    public int getCapacity() {
        return capacity;
    }
    
    public void setCapacity(int nextCapacity) {
        capacity = nextCapacity;
    }
    
    public boolean hasTile(MapCoords coords) {
        return train.stream().anyMatch((tile) -> (tile.getPos().equals(coords)));
    }
    
    public void append(MapCoords coords) {
        int secondToLast = train.size() - 2;
        if (secondToLast >= 0 && coords.equals(train.get(secondToLast).getPos())) {
            train.removeLast().getNode().removeFromParent();
        } else if (train.size() + 1 > capacity || hasTile(coords)) {
            pathTo(coords);
        } else {
            push(coords);
        }
    }
    
    protected void pathTo(MapCoords coords) {
        Path path = new Path(train.getFirst().getPos(), coords, capacity);
        List<MapCoords> sequence = path.getSequence();
        clear();
        for (MapCoords pos : sequence) {
            push(pos);
        }
    }
    
    protected void push(MapCoords coords) {
        MoveArrowTile moveArrowTile = loadedArrowTiles.get(coords);
        if (moveArrowTile == null) {
            moveArrowTile = new MoveArrowTile(coords, assetManager);
            loadedArrowTiles.put(coords, moveArrowTile);
        }
        
        add(moveArrowTile);
    }
    
    public void add(MoveArrowTile next) {
        next.attachToCurrentMapIfNotAlready();
        train.addLast(next);
    }
    
    public void clear() {
        for (MoveArrowTile moveIndicator : train) {
            moveIndicator.getNode().removeFromParent();
        }
        
        train.clear();
    }
    
    public void setVisibility(boolean visible) {
        ColorRGBA color = visible ? new ColorRGBA(1, 1, 1, 0.9f) : ColorRGBA.BlackNoAlpha;
        for (int i = 1; i < train.size(); i++) {
            train.get(i).setColor(color);
        }
    }
    
    public void tick() {
        if (train.isEmpty()) {
            return;
        }
        
        ColorRGBA visible = new ColorRGBA(1, 1, 1, 0.9f);
        train.getLast().setIndex(MoveArrowTile.HEAD); //last is HEAD
        train.getLast().setColor(visible); //reveal it
        train.getFirst().setColor(ColorRGBA.BlackNoAlpha); //hide the first one
        for (int i = 1; i < train.size() - 1; i++) { //everything in between is either STEM or TURN
            train.get(i).adjust(visible, train.get(i - 1), train.get(i + 1));
        }
    }
    
    public TileFoundation[] asArray() {
        TileFoundation[] tilePath = new TileFoundation[train.size()];
        for (int i = 0; i < tilePath.length; i++) {
            tilePath[i] = train.get(i);
        }
        
        return tilePath;
    }
}
